---
title: "Data analysis report"
author: "Lucas Veras"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    number_sections: true
    toc_float: 
      collapsed: false
    theme: flatly
    code_folding: "show"
editor_options: 
  chunk_output_type: console
---
<style>
TOC {
  top: 1%;
  opacity: 0.5;
  position: fixed;
  left: 0;
  top: 0;
  width: 0.5cm;
  height: 100%;
  overflow:auto;
}
TOC:hover {
  opacity: 1;
}
</style>

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

# Background 

Almost all accelerometer calibration studies were developed for non-obese people, which hampers an accurate prediction of energy expenditure (EE) and induces a misclassification of sedentary activity (SA) and physical activity intensities (PAI) in class II-III obese people. Therefore, the purpose of this study was to develop regression equations to predict EE and cut-points to classify SA and PAI in severe obese people based on several metrics obtained from hip and back accelerometer placement data.

# Preparing data {#prep_data}

```{r load_packs}
# Load packages and functions
library(here)
library(knitr)
library(tidyverse)
library(nlme)
library(piecewiseSEM)
library(pROC)
library(irr)
library(pgirmess)
source(here("R", "get_MET.R"))
source(here("R", "get_PAI_categories.R"))
source(here("R", "get_HR_res.R"))
source(here("R", "get_kcal.R"))
source(here("R", "cross_validate_mixed_model.R"))
source(here("R", "cross_validate_ROC_curves.R"))
source(here("R", "accuracy_indices.R"))
source(here("R", "percent_agreement.R"))
```

First, data needed to be loaded. `cardio` data frame contains cardiorespiratory and demographic variables, while `..._pri_acc` and `..._sec_acc` data frames cointains, respectively, primary and secondary accelerometer data for each accelerometer placement.

In all data frames, `speed` 0 identifies the sitting rest phase, `speed` 1 identifies standind rest phase, and all other `speed` values identify walking speed in km^.^h^-1^.

Accelerometer metrics used were activity counts (AC), mean amplitude deviation (MAD) **(insert refs)** and euclidean norm minus one (ENMO) **(insert refs)**. All metrics were computed based on resultant vector data. Primary accelerometer was only used to obtain AC, as it can be only obtained from primary accelerometer data and computed according to proprietary procedures **(insert refs)**. Secondary accelerometer was used to obtain raw acceleration data and to compute MAD and ENMO, because, unlike the primary accelerometer, it does not apply any filtering on data. All accelerometer metrics values on the data frames are averages of 5 sec epochs of each protocol period.

```{r prep_data}
cardio       <- read_csv(here("data", "cardio_data.csv"))
hip_pri_acc  <- read_csv(here("data", "hip_pri_acc.csv"))
hip_sec_acc  <- read_csv(here("data", "hip_sec_acc.csv"))
back_pri_acc <- read_csv(here("data", "back_pri_acc.csv"))
back_sec_acc <- read_csv(here("data", "back_sec_acc.csv"))
```

Some computations were made to obtain other variables using user-defined functions. get_MET **(insert link)** function computes metabolic equivalents (MET) based on the sitting rest phase oxygen uptake (VO~2~). get_PAI_categories **(insert link)** computes sedentary activity (SA) and physical activity intensities (PAI) categories based on MET values. Activities were classified as: ≤ 1.5 MET – SA; 1.6–2.9 MET – light physical activity (LPA);  3.0–6.0 MET – moderate physical activity (MPA); and >5.5 MET – vigorous physical activity (VPA) **(insert refs)**. These variables were also recoded to create ordinal variables, according to the following identification: 1 – SA, 2 – LPA, 3 – MPA and 4 – VPA.get_HR_res **(insert link)** computes percentages of heart rate reserve and get_kcal **(insert link)** computes kilocalories values based on VO~2~ and carbon dioxide production (VCO~2~) **(insert refs)**.

```{r computations}
# Compute MET values
cardio <- do.call(rbind, (lapply(unique(cardio$ID), get_MET, df = cardio)))
# Get PAI categories by MET
cardio <- get_PAI_categories(cardio)
# Compute percent HR reserve values
cardio <- do.call(rbind, (lapply(unique(cardio$ID), get_HR_res, df = cardio)))
# Compute kcal values
cardio <- do.call(rbind, (lapply(unique(cardio$ID), get_kcal, df = cardio)))
```

Finally, `cardio` and `..._acc` data frames were merged to obtain a single data frame to each accelerometer placement. Key variables used to connect each pair of data frames were `ID` and `speed`. A key is a variable (or set of variables) that uniquely identifies an observation  **(insert refs)**. 

```{r merging}
# Merge related data frames
hip <- hip_pri_acc %>% 
  select(-c(MAD, ENMO)) %>% 
  full_join(hip_sec_acc, by = c("ID", "speed")) %>% 
  left_join(cardio, by = c("ID", "speed")) %>% 
  select(-c(BF, V.E, V.O2, Evaluation, Date)) %>% 
  select(ID, speed, AC, MAD, ENMO, kcal, VO2.kg, MET, HR, percent_HR_res, everything())

back <- back_pri_acc %>% 
  select(-c(MAD, ENMO)) %>% 
  full_join(back_sec_acc, by = c("ID", "speed")) %>% 
  left_join(cardio, by = c("ID", "speed")) %>% 
  select(-c(BF, V.E, V.O2, Evaluation, Date)) %>% 
  select(ID, speed, AC, MAD, ENMO, kcal, VO2.kg, MET, HR, percent_HR_res, everything())
```

A piece of a data frame used in all subsequent analysis can be seen below.

```{r data_example}
back
```

# Sample descriptives

```{r sample_descriptives}
samp_desc <- read_csv(here("data", "sample_descriptives_data.csv"))
descriptives <- summarise(
  .data = samp_desc,
  age_mean    = round(mean(age), digits = 1),
  age_sd      = round(sd(age), digits = 1),
  weight_mean = round(mean(weight_kg), digits = 1),
  weight_sd   = round(sd(weight_kg), digits = 1),
  height_mean = round(mean(height_cm), digits = 1),
  height_sd   = round(sd(height_cm), digits = 1),
  BMI_mean    = round(mean(BMI_kgm2), digits = 1),
  BMI_sd      = round(sd(BMI_kgm2), digits = 1),
  fat_mean    = round(mean(body_fat), digits = 1),
  fat_sd      = round(sd(body_fat), digits = 1)
)
sex <- table(samp_desc$sex)
```

`r nrow(samp_desc)` class II-II obese adults (`r sex[[2]]` males, `r sex[[1]]` females; age: `r descriptives$age_mean`±`r descriptives$age_sd`yrs; height: `r descriptives$height_mean`±`r descriptives$height_sd`cm; weight: `r descriptives$weight_mean`±`r descriptives$weight_sd`kg; BMI: `r descriptives$BMI_mean`±`r descriptives$BMI_sd`kg^.^m^-2^; body fat: `r descriptives$fat_mean`±`r descriptives$fat_sd`%).

# Linear mixed models

Linear mixed models (LMM) **(insert refs)** were applied to predict kilocalories, that was used as the criterion measure of energy expenditure (EE). Distinct LMMs were developed with data from hip and back accelerometer placement using the `lme` function of the `nlme` [package](https://cran.r-project.org/web/packages/nlme/nlme.pdf). Covariance structure used was an autoregressive process of order 1 (`correlation = corAR1`) and maximum likelihood method was used for estimating parameters (`method = "ML"`). AC, MAD, ENMO, sex, age, body mass and BMI were tested as fixed effects, but only weight and the accelerometer metrics have shown to be significant predictors (*e.g.:* `fixed = kcal ~ AC + I(AC^2) + Weight`). Although random slopes have been tested, only the inclusion of random intercept has showed model improvement (`random = ~ 1 | ID`). Linear, quadratic and cubic slopes were also tested, whereas the last one did not contribute significantly to the models. Final models were chosen according to -2 log-likelihood statistics. Traditional coefficient of determination (R^2^) was represented by conditional R^2^ **insert refs**  computed with `rsquared` function of the `piecewiseSEM` [package](http://jslefche.github.io/piecewiseSEM/articles/piecewiseSEM.html), that estimates the variance explained by the whole model **insert refs**.

```{r LMM}
# Hip accelerometer
## AC
hip_AC_model <- lme(
  fixed = kcal ~ AC + I(AC^2) + Weight,
  random = ~ 1 | ID,
  method = "ML",
  correlation = corAR1(),
  data = hip,
  na.action = na.omit
)
r2_hip_AC_model <- rsquared(hip_AC_model)

## MAD
hip_MAD_model <- lme(
  fixed = kcal ~ MAD + I(MAD^2) + Weight,
  random = ~ 1 | ID,
  method = "ML",
  correlation = corAR1(),
  data = hip,
  na.action = na.omit
)
r2_hip_MAD_model <- rsquared(hip_MAD_model)

## ENMO
hip_ENMO_model <- lme(
  fixed = kcal ~ ENMO + I(ENMO^2) + Weight,
  random = ~ 1 | ID,
  method = "ML",
  correlation = corAR1(),
  data = hip,
  na.action = na.omit
)
r2_hip_ENMO_model <- rsquared(hip_ENMO_model)

# Back accelerometer
## AC
back_AC_model <- lme(
  fixed = kcal ~ AC + I(AC^2) + Weight,
  random = ~ 1 | ID,
  method = "ML",
  correlation = corAR1(),
  data = back,
  na.action = na.omit
)
r2_back_AC_model <- rsquared(back_AC_model)

## MAD
back_MAD_model <- lme(
  fixed = kcal ~ MAD + I(MAD^2) + Weight,
  random = ~ 1 | ID,
  method = "ML",
  correlation = corAR1(),
  data = back,
  na.action = na.omit
)
r2_back_MAD_model <- rsquared(back_MAD_model)

## ENMO
back_ENMO_model <- lme(
  fixed = kcal ~ ENMO + I(ENMO^2) + Weight,
  random = ~ 1 | ID,
  method = "ML",
  correlation = corAR1(),
  data = back,
  na.action = na.omit
)
r2_back_ENMO_model <- rsquared(back_ENMO_model)
```

# Receiver operating characteristic curves

Cut-points that identify SA and PAI created from AC, MAD and ENMO were obtained applying receiver operating characteristic curves (ROC) **insert refs**, for both hip and back accelerometer placement data. The indices used to summarize the cut-points were sensitivity (proportion of true positives that are correctly identified), specificity (proportion of false positive that are correctly identified) and the area under the curve. MET values were computed with get_MET **insert link** function as described [here](#prep_data). Resting metabolic rate (RMR), represented by sitting position period VO~2~, was not used in the ROC analyses. Activities were classified as SA, LPA, MPA and VPA based on MET values with get_PAI_categories **insert link** function as described [here](#prep_data). To perform ROC analyses, METs were recoded to create binary variables (0 or 1). The activity to be identified was codified as 1 and the others as 0. This was also done with get_PAI_categories **insert link** function. LPA boundaries were provided with SA and MPA  cut-points. ROC curves were created using `roc` function of the `pROC` [package](https://cran.r-project.org/web/packages/pROC/pROC.pdf). Optimal cut-points were chosen using the closest-to-(0,1) criterion with `coords` function, also of the `pROC` [package](https://cran.r-project.org/web/packages/pROC/pROC.pdf) (`coords(roc, x = "best", best.method = "closest.topleft")`) **insert refs**.

```{r ROC_curves}
# Hip accelerometer
## AC
hip_AC_ROC_SED <- roc(SED_CAT_by_MET ~ AC, ci = TRUE, data = hip, na.rm = TRUE)
hip_AC_ROC_MOD <- roc(MOD_CAT_by_MET ~ AC, ci = TRUE, data = hip, na.rm = TRUE)
hip_AC_ROC_VIG <- roc(VIG_CAT_by_MET ~ AC, ci = TRUE, data = hip, na.rm = TRUE)
cp_hip_AC_ROC_SED <- coords(hip_AC_ROC_SED, x = "best", best.method = "closest.topleft")
cp_hip_AC_ROC_MOD <- coords(hip_AC_ROC_MOD, x = "best", best.method = "closest.topleft")
cp_hip_AC_ROC_VIG <- coords(hip_AC_ROC_VIG, x = "best", best.method = "closest.topleft")

## MAD
hip_MAD_ROC_SED <- roc(SED_CAT_by_MET ~ MAD, ci = TRUE, data = hip, na.rm = TRUE)
hip_MAD_ROC_MOD <- roc(MOD_CAT_by_MET ~ MAD, ci = TRUE, data = hip, na.rm = TRUE)
hip_MAD_ROC_VIG <- roc(VIG_CAT_by_MET ~ MAD, ci = TRUE, data = hip, na.rm = TRUE)
cp_hip_MAD_ROC_SED <- coords(hip_MAD_ROC_SED, x = "best", best.method = "closest.topleft")
cp_hip_MAD_ROC_MOD <- coords(hip_MAD_ROC_MOD, x = "best", best.method = "closest.topleft")
cp_hip_MAD_ROC_VIG <- coords(hip_MAD_ROC_VIG, x = "best", best.method = "closest.topleft")

## ENMO
hip_ENMO_ROC_SED <- roc(SED_CAT_by_MET ~ ENMO, ci = TRUE, data = hip, na.rm = TRUE)
hip_ENMO_ROC_MOD <- roc(MOD_CAT_by_MET ~ ENMO, ci = TRUE, data = hip, na.rm = TRUE)
hip_ENMO_ROC_VIG <- roc(VIG_CAT_by_MET ~ ENMO, ci = TRUE, data = hip, na.rm = TRUE)
cp_hip_ENMO_ROC_SED <- coords(hip_ENMO_ROC_SED, x = "best", best.method = "closest.topleft")
cp_hip_ENMO_ROC_MOD <- coords(hip_ENMO_ROC_MOD, x = "best", best.method = "closest.topleft")
cp_hip_ENMO_ROC_VIG <- coords(hip_ENMO_ROC_VIG, x = "best", best.method = "closest.topleft")

# Back accelerometer
## AC
back_AC_ROC_SED <- roc(SED_CAT_by_MET ~ AC, ci = TRUE, data = back, na.rm = TRUE)
back_AC_ROC_MOD <- roc(MOD_CAT_by_MET ~ AC, ci = TRUE, data = back, na.rm = TRUE)
back_AC_ROC_VIG <- roc(VIG_CAT_by_MET ~ AC, ci = TRUE, data = back, na.rm = TRUE)
cp_back_AC_ROC_SED <- coords(back_AC_ROC_SED, x = "best", best.method = "closest.topleft")
cp_back_AC_ROC_MOD <- coords(back_AC_ROC_MOD, x = "best", best.method = "closest.topleft")
cp_back_AC_ROC_VIG <- coords(back_AC_ROC_VIG, x = "best", best.method = "closest.topleft")

## MAD
back_MAD_ROC_SED <- roc(SED_CAT_by_MET ~ MAD, ci = TRUE, data = back, na.rm = TRUE)
back_MAD_ROC_MOD <- roc(MOD_CAT_by_MET ~ MAD, ci = TRUE, data = back, na.rm = TRUE)
back_MAD_ROC_VIG <- roc(VIG_CAT_by_MET ~ MAD, ci = TRUE, data = back, na.rm = TRUE)
cp_back_MAD_ROC_SED <- coords(back_MAD_ROC_SED, x = "best", best.method = "closest.topleft")
cp_back_MAD_ROC_MOD <- coords(back_MAD_ROC_MOD, x = "best", best.method = "closest.topleft")
cp_back_MAD_ROC_VIG <- coords(back_MAD_ROC_VIG, x = "best", best.method = "closest.topleft")

## ENMO
back_ENMO_ROC_SED <- roc(SED_CAT_by_MET ~ ENMO, ci = TRUE, data = back, na.rm = TRUE)
back_ENMO_ROC_MOD <- roc(MOD_CAT_by_MET ~ ENMO, ci = TRUE, data = back, na.rm = TRUE)
back_ENMO_ROC_VIG <- roc(VIG_CAT_by_MET ~ ENMO, ci = TRUE, data = back, na.rm = TRUE)
cp_back_ENMO_ROC_SED <- coords(back_ENMO_ROC_SED, x = "best", best.method = "closest.topleft")
cp_back_ENMO_ROC_MOD <- coords(back_ENMO_ROC_MOD, x = "best", best.method = "closest.topleft")
cp_back_ENMO_ROC_VIG <- coords(back_ENMO_ROC_VIG, x = "best", best.method = "closest.topleft")
```

# Validation analysis

The validity of equations and cut-points developed were posteriorly analyzed through leave-one-out cross-validation (LOOCV) method **insert refs**. Hence, each participant’s data was separated into a testing dataset (one at a time) with the remaining data being in the training dataset. New LMM and ROC, with the same structure as determined for the entire sample, were developed using the training dataset to predict kilocalories and identify SA or PAI for the only participant in the testing dataset. This process was repeated for all participants (`r nrow(samp_desc)` times).  

LOOCV of the LMM was done with the cross_validate_mixed_model **insert link** function and is shown below.

```{r LMM_LOOCV}
# Leave-one-out cross-validation
# Mixed models
## Hip accelerometer
### AC
fix_eff    <- kcal ~ AC + I(AC^2) + Weight
rand_eff   <- ~ 1 | ID
acc_metric <- "AC"
LOOCV_hip_AC_model <- do.call(rbind, (lapply(unique(hip$ID), cross_validate_mixed_model, df = hip)))

### MAD
fix_eff    <- kcal ~ MAD + I(MAD^2) + Weight
rand_eff   <- ~ 1 | ID
acc_metric <- "MAD"
LOOCV_hip_MAD_model <- do.call(rbind, (lapply(unique(hip$ID), cross_validate_mixed_model, df = hip)))

### ENMO
fix_eff    <- kcal ~ ENMO + I(ENMO^2) + Weight
rand_eff   <- ~ 1 | ID
acc_metric <- "ENMO"
LOOCV_hip_ENMO_model <- do.call(rbind, (lapply(unique(hip$ID), cross_validate_mixed_model, df = hip)))

## Back accelerometer
### AC
fix_eff    <- kcal ~ AC + I(AC^2) + Weight
rand_eff   <- ~ 1 | ID
acc_metric <- "AC"
LOOCV_back_AC_model <- do.call(rbind, (lapply(unique(back$ID), cross_validate_mixed_model, df = back)))

### MAD
fix_eff    <- kcal ~ MAD + I(MAD^2) + Weight
rand_eff   <- ~ 1 | ID
acc_metric <- "MAD"
LOOCV_back_MAD_model <- do.call(rbind, (lapply(unique(back$ID), cross_validate_mixed_model, df = back)))

### ENMO
fix_eff    <- kcal ~ ENMO + I(ENMO^2) + Weight
rand_eff   <- ~ 1 | ID
acc_metric <- "ENMO"
LOOCV_back_ENMO_model <- do.call(rbind, (lapply(unique(back$ID), cross_validate_mixed_model, df = back)))
```

LOOCV of the ROC curves was done with the cross_validate_ROC_curves **insert link** function and is shown below.

```{r ROC_LOOCV}
# Leave-one-out cross-validation
# ROC curves
## Hip accelerometer
### AC
LOOCV_hip_AC_ROC <- do.call(rbind, (lapply(unique(hip$ID)[-1], # drop 1st ID (36); does not have valid AC
                                    cross_validate_ROC_curves, 
                                    df = hip, acc_metric = "AC")))

### MAD
LOOCV_hip_MAD_ROC <- do.call(rbind, (lapply(unique(hip$ID),
                                     cross_validate_ROC_curves,
                                     df = hip, acc_metric = "MAD")))

### ENMO
LOOCV_hip_ENMO_ROC <- do.call(rbind, (lapply(unique(hip$ID),
                                      cross_validate_ROC_curves,
                                      df = hip, acc_metric = "ENMO")))

## Back accelerometer
### AC
LOOCV_back_AC_ROC <- do.call(rbind, (lapply(unique(back$ID), 
                                     cross_validate_ROC_curves, 
                                     df = back, acc_metric = "AC")))

### MAD
LOOCV_back_MAD_ROC <- do.call(rbind, (lapply(unique(back$ID),
                                      cross_validate_ROC_curves,
                                      df = back, acc_metric = "MAD")))

### ENMO
LOOCV_back_ENMO_ROC <- do.call(rbind, (lapply(unique(back$ID),
                                       cross_validate_ROC_curves,
                                       df = back, acc_metric = "ENMO")))
```

Data from testing dataset were used in the following validation analyses.

## Bland-Altman plots

Agreement between kilocalories computed from data obtained from indirect calorimetry and predicted kilocalories was assessed by Bland-Altman plots **insert refs**. The difference of the measured and predicted kilocalories was plotted against their mean. The mean of these differences represented the bias and this mean was also used to calculate the limits of agreement with 95% confidence intervals (LoA). 

Bland-Altman plots can be seen below for all accelerometer metrics. Panel **A** shows plots of hip placement and panel **B** shows plots of back placement.

```{r BA_plots, fig.height=15, fig.width=13, dev='svg'}
source(here("figs", "fig1.R"))

BA_plot_grid
```

Code to generate these plots can be seen here **insert link**

<br>

Linear regressions (LR) were applied to identify if there was any proportional bias, that is, if bias was related with the magnitude of the mean between measured and predicted kilocalories. LR were run using the `lm` function of the base R. No proportional bias was identified (*p*<0.05).

```{r BA_LR}
# Linear regressions
# Hip accelerometer
## AC
hip_AC_BA_plot_LR <- lm(diff ~ mean, data = LOOCV_hip_AC_model)
summary(hip_AC_BA_plot_LR)

## MAD
hip_MAD_BA_plot_LR <- lm(diff ~ mean, data = LOOCV_hip_MAD_model)
summary(hip_MAD_BA_plot_LR)

## ENMO
hip_ENMO_BA_plot_LR <- lm(diff ~ mean, data = LOOCV_hip_ENMO_model)
summary(hip_ENMO_BA_plot_LR)

# Back accelerometer
## AC
back_AC_BA_plot_LR <- lm(diff ~ mean, data = LOOCV_back_AC_model)
summary(back_AC_BA_plot_LR)

## MAD
back_MAD_BA_plot_LR <- lm(diff ~ mean, data = LOOCV_back_MAD_model)
summary(back_MAD_BA_plot_LR)

## ENMO
back_ENMO_BA_plot_LR <- lm(diff ~ mean, data = LOOCV_back_ENMO_model)
summary(back_ENMO_BA_plot_LR)
```

## Indices of accuracy

The accuracy of predicted kilocalories was assessed by mean absolute error (MAE), mean absolute percent error (MAPE), and root mean square error (RMSE). These indices were computed with the accuracy_indices function **insert link**.

```{r indices_of_accuracy}
# Hip accelerometer
## AC
hip_AC_model_accuracy <- accuracy_indices(LOOCV_hip_AC_model, "kcal", "kcal_predicted")

## MAD
hip_MAD_model_acccuracy <- accuracy_indices(LOOCV_hip_MAD_model, "kcal", "kcal_predicted")

## ENMO
hip_ENMO_model_acccuracy <- accuracy_indices(LOOCV_hip_ENMO_model, "kcal", "kcal_predicted")

# Back accelerometer
## AC
back_AC_model_accuracy <- accuracy_indices(LOOCV_back_AC_model, "kcal", "kcal_predicted")

## MAD
back_MAD_model_acccuracy <- accuracy_indices(LOOCV_back_MAD_model, "kcal", "kcal_predicted")

## ENMO
back_ENMO_model_acccuracy <- accuracy_indices(LOOCV_back_ENMO_model, "kcal", "kcal_predicted")
```

Table below shows these indices for all accelerometer placement and metrics.

```{r accuracy_table}
accuracy <- data.frame(
  acc_placement = c(rep("hip", 3), rep("back", 3)),
  acc_metric    = rep(c("AC", "MAD", "ENMO"), 2),
  MAE           = c(
    hip_AC_model_accuracy[[5]], hip_MAD_model_acccuracy[[5]], hip_ENMO_model_acccuracy[[5]],
    back_AC_model_accuracy[[5]], back_MAD_model_acccuracy[[5]], back_ENMO_model_acccuracy[[5]]
    ),
  MAPE          = c(
    hip_AC_model_accuracy[[12]], hip_MAD_model_acccuracy[[12]], hip_ENMO_model_acccuracy[[12]],
    back_AC_model_accuracy[[12]], back_MAD_model_acccuracy[[12]], back_ENMO_model_acccuracy[[12]]
    ),
  RMSE          = c(
    hip_AC_model_accuracy[[7]], hip_MAD_model_acccuracy[[7]], hip_ENMO_model_acccuracy[[7]],
    back_AC_model_accuracy[[7]], back_MAD_model_acccuracy[[7]], back_ENMO_model_acccuracy[[7]]
    )
)
kable(accuracy)
```

All conditions showed a MAE near `r round(mean(accuracy$MAE), digits = 1)` kcal, MAPE from near `r round(min(accuracy$MAPE), digits = 0)`% to near  `r round(max(accuracy$MAPE), digits = 0)`% and RMSE of approximately `r round(mean(accuracy$RMSE), digits = 2)` kcal.

## Kappa statistic

Kappa statistic (κ) was used to measure the classification agreement of SA and PAI obtained from indirect calorimetry and those obtained from cut-points **insert refs**. Individual classification agreement analyses for SA, LPA, MPA and VPA were done with unweighted Kappa method **insert refs**. Because the whole classification included four ordinal categories, the disagreement magnitude among them (e.g., misclassified by two or more categories instead of one) was also analyzed in a global classification agreement utilizing a quadratic weighted Kappa method **insert refs**. 
To perform unweighted Kappa analyses, METs obtained from indirect calorimetry and values of AC, MAD, ENMO included in cut-points of SA, LPA, MPA and VPA were recoded to create binary variables (0 or 1), wherein 1 was the activity to be identified and 0 the others. For quadratic weighted Kappa analyses, METs obtained from indirect calorimetry and values of AC, MAD and ENMO included in cut-points for SA, LPA, MPA and VPA were recoded to create ordinal variables, according to the following identification: 1 – SA, 2 – LPA, 3 – MPA and 4 – VPA. These variables were created with the get_PAI_categories **insert link** function, as described [here](#prep_data).

All Kappa statistic analyses were conducted with `kappa2` function of the `irr` [package](https://cran.r-project.org/web/packages/irr/irr.pdf). For the quadratic weighted Kappa, *"weight"* argument was set as *"squared"* (`weight = "squared"`).
 
A Kappa coefficient of <0 is considered poor, .00–.20 slight, .21–.40 fair, .41–.60 moderate, .61–.80 substantial, and .81–1.00 almost perfect **insert refs**.

Kappa statistic results for all accelerometer metric of hip placement can be found on table below. For all metrics, VPA showed the lowest Kappa coefficient (classified as moderate). All other PAI showed Kappa coefficients classified as substantial or almost perfect.
 
```{r kappa_hip}
# Hip accelerometer
## AC
kappa_hip_AC_SED  <- kappa2(select(LOOCV_hip_AC_ROC, SED_CAT_by_MET, SED_CAT_by_ROC))
kappa_hip_AC_MOD  <- kappa2(select(LOOCV_hip_AC_ROC, MOD_CAT_by_MET, MOD_CAT_by_ROC))
kappa_hip_AC_VIG  <- kappa2(select(LOOCV_hip_AC_ROC, VIG_CAT_by_MET, VIG_CAT_by_ROC))
kappa_hip_AC_glob <- kappa2(select(LOOCV_hip_AC_ROC, INTENS_CAT_by_MET, INTENS_CAT_by_ROC), 
                            weight = "squared")

## MAD
kappa_hip_MAD_SED  <- kappa2(select(LOOCV_hip_MAD_ROC, SED_CAT_by_MET, SED_CAT_by_ROC))
kappa_hip_MAD_MOD  <- kappa2(select(LOOCV_hip_MAD_ROC, MOD_CAT_by_MET, MOD_CAT_by_ROC))
kappa_hip_MAD_VIG  <- kappa2(select(LOOCV_hip_MAD_ROC, VIG_CAT_by_MET, VIG_CAT_by_ROC))
kappa_hip_MAD_glob <- kappa2(select(LOOCV_hip_MAD_ROC, INTENS_CAT_by_MET, INTENS_CAT_by_ROC), 
                             weight = "squared")

## ENMO
kappa_hip_ENMO_SED  <- kappa2(select(LOOCV_hip_ENMO_ROC, SED_CAT_by_MET, SED_CAT_by_ROC))
kappa_hip_ENMO_MOD  <- kappa2(select(LOOCV_hip_ENMO_ROC, MOD_CAT_by_MET, MOD_CAT_by_ROC))
kappa_hip_ENMO_VIG  <- kappa2(select(LOOCV_hip_ENMO_ROC, VIG_CAT_by_MET, VIG_CAT_by_ROC))
kappa_hip_ENMO_glob <- kappa2(select(LOOCV_hip_ENMO_ROC, INTENS_CAT_by_MET, INTENS_CAT_by_ROC), 
                              weight = "squared")

kappa_hip <- data.frame(
  acc_metric = c(rep("AC", 4), rep("MAD", 4), rep("ENMO", 4)),
  intens_cat = c("Sedentary", "Moderate", "Vigorous", "Global"),
  kappa      = c(
    round(kappa_hip_AC_SED[[5]], digits = 2), round(kappa_hip_AC_MOD[[5]], digits = 2), round(kappa_hip_AC_VIG[[5]], digits = 2), round(kappa_hip_AC_glob[[5]], digits = 2), round(kappa_hip_MAD_SED[[5]], digits = 2), round(kappa_hip_MAD_MOD[[5]], digits = 2), round(kappa_hip_MAD_VIG[[5]], digits = 2), round(kappa_hip_MAD_glob[[5]], digits = 2), round(kappa_hip_ENMO_SED[[5]], digits = 2), round(kappa_hip_ENMO_MOD[[5]], digits = 2), round(kappa_hip_ENMO_VIG[[5]], digits = 2), round(kappa_hip_ENMO_glob[[5]], digits = 2)
  ),
  weight     = c(rep("unweighted", 3), "quadratic")
)
kable(kappa_hip)
```

Kappa statistic results for all accelerometer metric of back placement can be found on table below. Similar to hip placement, for all metrics, VPA showed the lowest Kappa coefficient (classified as moderate). All other PAI showed Kappa coefficients classified as substantial or almost perfect.

```{r kappa_back}
# Back accelerometer
## AC
kappa_back_AC_SED  <- kappa2(select(LOOCV_back_AC_ROC, SED_CAT_by_MET, SED_CAT_by_ROC))
kappa_back_AC_MOD  <- kappa2(select(LOOCV_back_AC_ROC, MOD_CAT_by_MET, MOD_CAT_by_ROC))
kappa_back_AC_VIG  <- kappa2(select(LOOCV_back_AC_ROC, VIG_CAT_by_MET, VIG_CAT_by_ROC))
kappa_back_AC_glob <- kappa2(select(LOOCV_back_AC_ROC, INTENS_CAT_by_MET, INTENS_CAT_by_ROC), 
                             weight = "squared")

## MAD
kappa_back_MAD_SED  <- kappa2(select(LOOCV_back_MAD_ROC, SED_CAT_by_MET, SED_CAT_by_ROC))
kappa_back_MAD_MOD  <- kappa2(select(LOOCV_back_MAD_ROC, MOD_CAT_by_MET, MOD_CAT_by_ROC))
kappa_back_MAD_VIG  <- kappa2(select(LOOCV_back_MAD_ROC, VIG_CAT_by_MET, VIG_CAT_by_ROC))
kappa_back_MAD_glob <- kappa2(select(LOOCV_back_MAD_ROC, INTENS_CAT_by_MET, INTENS_CAT_by_ROC), 
                              weight = "squared")

## ENMO
kappa_back_ENMO_SED  <- kappa2(select(LOOCV_back_ENMO_ROC, SED_CAT_by_MET, SED_CAT_by_ROC))
kappa_back_ENMO_MOD  <- kappa2(select(LOOCV_back_ENMO_ROC, MOD_CAT_by_MET, MOD_CAT_by_ROC))
kappa_back_ENMO_VIG  <- kappa2(select(LOOCV_back_ENMO_ROC, VIG_CAT_by_MET, VIG_CAT_by_ROC))
kappa_back_ENMO_glob <- kappa2(select(LOOCV_back_ENMO_ROC, INTENS_CAT_by_MET, INTENS_CAT_by_ROC), 
                               weight = "squared")

kappa_back <- data.frame(
  acc_metric = c(rep("AC", 4), rep("MAD", 4), rep("ENMO", 4)),
  intens_cat = c("Sedentary", "Moderate", "Vigorous", "Global"),
  kappa      = c(
    round(kappa_back_AC_SED[[5]], digits = 2), round(kappa_back_AC_MOD[[5]], digits = 2), round(kappa_back_AC_VIG[[5]], digits = 2), round(kappa_back_AC_glob[[5]], digits = 2), round(kappa_back_MAD_SED[[5]], digits = 2), round(kappa_back_MAD_MOD[[5]], digits = 2), round(kappa_back_MAD_VIG[[5]], digits = 2), round(kappa_back_MAD_glob[[5]], digits = 2), round(kappa_back_ENMO_SED[[5]], digits = 2), round(kappa_back_ENMO_MOD[[5]], digits = 2), round(kappa_back_ENMO_VIG[[5]], digits = 2), round(kappa_back_ENMO_glob[[5]], digits = 2)
  ),
  weight     = c(rep("unweighted", 3), "quadratic")
)
kable(kappa_back)
```

## Percent agreement

Percent agreement from global classification was also calculated. Hence, SA, LPA, MPA and VPA classification created from cut-points in each accelerometer metric from hip and back placement were recoded to create binary variables (0 or 1). The activity correctly identified was coded as 1 and the opposite as 0, taking as reference the classification obtained by indirect calorimetry. Percent agreement was calculated by percent_agreement **insert link** function through the sum of activities correctly identified divided by the sum of all activities and then multiplied by 100.

Table below shows percent agreement for all accelerometer placements and metrics. 

```{r percent_agreement}
# Hip accelerometer
## AC
perc_agree_hip_AC_ROC <- percent_agreement(LOOCV_hip_AC_ROC, "INTENS_CAT_by_MET", "INTENS_CAT_by_ROC")

## MAD
perc_agree_hip_MAD_ROC <- percent_agreement(LOOCV_hip_MAD_ROC, "INTENS_CAT_by_MET", "INTENS_CAT_by_ROC")

## ENMO
perc_agree_hip_ENMO_ROC <- percent_agreement(LOOCV_hip_ENMO_ROC, "INTENS_CAT_by_MET", "INTENS_CAT_by_ROC")

# Back accelerometer
## AC
perc_agree_back_AC_ROC <- percent_agreement(LOOCV_back_AC_ROC, "INTENS_CAT_by_MET", "INTENS_CAT_by_ROC")

## MAD
perc_agree_back_MAD_ROC <- percent_agreement(LOOCV_back_MAD_ROC, "INTENS_CAT_by_MET", "INTENS_CAT_by_ROC")

## ENMO
perc_agree_back_ENMO_ROC <- percent_agreement(LOOCV_back_ENMO_ROC, "INTENS_CAT_by_MET", "INTENS_CAT_by_ROC")

perc_agree <- data.frame(
  acc_placement     = c(rep("Hip", 3), rep("Back", 3)),
  acc_metric        = rep(c("AC", "MAD", "ENMO"), 2),
  percent_agreement = c(
    perc_agree_hip_AC_ROC, perc_agree_hip_MAD_ROC, perc_agree_hip_ENMO_ROC,
    perc_agree_back_AC_ROC, perc_agree_back_MAD_ROC, perc_agree_back_ENMO_ROC
    )
)
kable(perc_agree)
```

All percent agreement values were above `r round(min(perc_agree$percent_agreement), digits = 0)`%.

# Prediction accuracy comparison

Accuracy comparison of predicted kilocalories among accelerometer metrics in each hip and back placement was analyzed using the absolute errors through the analysis of variance (ANOVA) with `aov` function of base R. Absolute errors were also used to compare prediction accuracy between hip and back placement for each accelerometer metric by the independent two-sample t-test with `t.test` function of base R.

To do these analysis, new data frames needed to be built, putting the absolute errors in a single variable and grouping them by accelerometer placement and metric in another variable.

Code to tidy the data is shown below, together with prediction accuracy comparison among accelerometer metrics. In both accelerometer placements, no differences in prediction accuracy were observed among accelerometer metrics (*p*>0.05).

```{r predic_comp_acc_metrics}
# Hip accelerometer (among accelerometer metrics)
## Building data frame
pred_error_hip_AC <- LOOCV_hip_AC_model %>% 
  select(ID, speed, kcal, kcal_predicted) %>% 
  mutate(abs_error_hip_AC = abs(kcal - kcal_predicted)) %>% 
  select(ID, speed, abs_error_hip_AC)

pred_error_hip_MAD <- LOOCV_hip_MAD_model %>% 
  select(ID, speed, kcal, kcal_predicted) %>% 
  mutate(abs_error_hip_MAD = abs(kcal - kcal_predicted)) %>% 
  select(ID, speed, abs_error_hip_MAD)

pred_error_hip_ENMO <- LOOCV_hip_ENMO_model %>% 
  select(ID, speed, kcal, kcal_predicted) %>% 
  mutate(abs_error_hip_ENMO = abs(kcal - kcal_predicted)) %>% 
  select(ID, speed, abs_error_hip_ENMO)

hip_ANOVA_df <- pred_error_hip_AC %>%
  left_join(pred_error_hip_MAD, by = c("ID", "speed")) %>% 
  left_join(pred_error_hip_ENMO, by = c("ID", "speed")) %>% 
  gather(
    abs_error_hip_AC, abs_error_hip_MAD, abs_error_hip_ENMO,
    key = metric,
    value = absolute_error
  )

## Running test
hip_ANOVA <- aov(absolute_error ~ metric, data = hip_ANOVA_df)
summary(hip_ANOVA)

# Back accelerometer (among accelerometer metrics)
## Building data frame
pred_error_back_AC <- LOOCV_back_AC_model %>% 
  select(ID, speed, kcal, kcal_predicted) %>% 
  mutate(abs_error_back_AC = abs(kcal - kcal_predicted)) %>% 
  select(ID, speed, abs_error_back_AC)

pred_error_back_MAD <- LOOCV_back_MAD_model %>% 
  select(ID, speed, kcal, kcal_predicted) %>% 
  mutate(abs_error_back_MAD = abs(kcal - kcal_predicted)) %>% 
  select(ID, speed, abs_error_back_MAD)

pred_error_back_ENMO <- LOOCV_back_ENMO_model %>% 
  select(ID, speed, kcal, kcal_predicted) %>% 
  mutate(abs_error_back_ENMO = abs(kcal - kcal_predicted)) %>% 
  select(ID, speed, abs_error_back_ENMO)

back_ANOVA_df <- pred_error_back_AC %>%
  left_join(pred_error_back_MAD, by = c("ID", "speed")) %>% 
  left_join(pred_error_back_ENMO, by = c("ID", "speed")) %>% 
  gather(
    abs_error_back_AC, abs_error_back_MAD, abs_error_back_ENMO,
    key = metric,
    value = absolute_error
  )

## Running test
back_ANOVA <- aov(absolute_error ~ metric, data = back_ANOVA_df)
summary(back_ANOVA)
```

Prediction accuracy comparison between hip and back placement for each accelerometer metric is show below. For all accelerometer metrics, no differences in prediction accuracy were observed between accelerometer placements (*p*>0.05).

```{r predic_comp_acc_place}
# AC metric (between accelerometers)
## Building data frame
AC_ttest_df <- pred_error_hip_AC %>% 
  left_join(pred_error_back_AC, by = c("ID", "speed")) %>% 
  gather(
    abs_error_hip_AC, abs_error_back_AC,
    key = placement,
    value = absolute_error
  )

## Running test
AC_ttest <- t.test(absolute_error ~ placement, data = AC_ttest_df)
AC_ttest

# MAD metric (between accelerometers)
## Building data frame
MAD_ttest_df <- pred_error_hip_MAD %>% 
  left_join(pred_error_back_MAD, by = c("ID", "speed")) %>% 
  gather(
    abs_error_hip_MAD, abs_error_back_MAD,
    key = placement,
    value = absolute_error
  )

## Running test
MAD_ttest <- t.test(absolute_error ~ placement, data = MAD_ttest_df)
MAD_ttest

# ENMO metric (between accelerometers)
## Building data frame
ENMO_ttest_df <- pred_error_hip_ENMO %>% 
  left_join(pred_error_back_ENMO, by = c("ID", "speed")) %>% 
  gather(
    abs_error_hip_ENMO, abs_error_back_ENMO,
    key = placement,
    value = absolute_error
  )

## Running test
ENMO_ttest <- t.test(absolute_error ~ placement, data = ENMO_ttest_df)
ENMO_ttest
```

# Classification agreement comparison

To compare classification agreement, ordinal classification (1 – SA, 2 – LPA, 3 – MPA and 4 – VPA) acquired by cut-points was subtracted to those obtained by indirect calorimetry to calculate the classification error. Absolute values of classification error were utilized to comparare classification agreement among accelerometer metrics in each position through Kruskal-Wallis test (with `kruskal.test` function of base R) and to compare each accelerometer metric between hip and back placement through Wilcoxon rank-sum test (with `wilcox.test` function of base R).

As happened with prediction accuracy compared, new data frames needed to be built with classification errors in a single variable and grouped in another variable by accelerometer placement and metric.

Code to tidy the data is shown below, together with classification agreement comparison among accelerometer metrics. For hip accelerometer placement, no differences of classification agreement were observed (*p*>0.05). For back accelerometer placement, although Kruskal-Wallis test *p* value was lower than 0.05, when *post hoc* tests were applied, no differences in classification agreement between each pair of accelerometer metrics were observed (*p*>0.05).

```{r class_agree_acc_metrics}
# Hip accelerometer (among accelerometer metrics)
## Building data frame
class_error_hip_AC <- LOOCV_hip_AC_ROC %>% 
  select(ID, speed, INTENS_CAT_by_MET, INTENS_CAT_by_ROC) %>% 
  mutate(abs_error_hip_AC = abs(INTENS_CAT_by_MET - INTENS_CAT_by_ROC)) %>% 
  select(ID, speed, abs_error_hip_AC)

class_error_hip_MAD <- LOOCV_hip_MAD_ROC %>% 
  select(ID, speed, INTENS_CAT_by_MET, INTENS_CAT_by_ROC) %>% 
  mutate(abs_error_hip_MAD = abs(INTENS_CAT_by_MET - INTENS_CAT_by_ROC)) %>% 
  select(ID, speed, abs_error_hip_MAD)

class_error_hip_ENMO <- LOOCV_hip_ENMO_ROC %>% 
  select(ID, speed, INTENS_CAT_by_MET, INTENS_CAT_by_ROC) %>% 
  mutate(abs_error_hip_ENMO = abs(INTENS_CAT_by_MET - INTENS_CAT_by_ROC)) %>% 
  select(ID, speed, abs_error_hip_ENMO)

hip_KW_df <- class_error_hip_AC %>% 
  left_join(class_error_hip_MAD, by = c("ID", "speed")) %>% 
  left_join(class_error_hip_ENMO, by = c("ID", "speed")) %>% 
  gather(
    abs_error_hip_AC, abs_error_hip_MAD, abs_error_hip_ENMO,
    key = metric,
    value = absolute_error
  )
hip_KW_df$metric <- as_factor(hip_KW_df$metric)

## Running test
hip_KW <- kruskal.test(absolute_error ~ metric, data = hip_KW_df)
hip_KW

# Back accelerometer (among accelerometer metrics)
## Building data frame
class_error_back_AC <- LOOCV_back_AC_ROC %>% 
  select(ID, speed, INTENS_CAT_by_MET, INTENS_CAT_by_ROC) %>% 
  mutate(abs_error_back_AC = abs(INTENS_CAT_by_MET - INTENS_CAT_by_ROC)) %>% 
  select(ID, speed, abs_error_back_AC)

class_error_back_MAD <- LOOCV_back_MAD_ROC %>% 
  select(ID, speed, INTENS_CAT_by_MET, INTENS_CAT_by_ROC) %>% 
  mutate(abs_error_back_MAD = abs(INTENS_CAT_by_MET - INTENS_CAT_by_ROC)) %>% 
  select(ID, speed, abs_error_back_MAD)

class_error_back_ENMO <- LOOCV_back_ENMO_ROC %>% 
  select(ID, speed, INTENS_CAT_by_MET, INTENS_CAT_by_ROC) %>% 
  mutate(abs_error_back_ENMO = abs(INTENS_CAT_by_MET - INTENS_CAT_by_ROC)) %>% 
  select(ID, speed, abs_error_back_ENMO)

back_KW_df <- class_error_back_AC %>% 
  left_join(class_error_back_MAD, by = c("ID", "speed")) %>% 
  left_join(class_error_back_ENMO, by = c("ID", "speed")) %>% 
  gather(
    abs_error_back_AC, abs_error_back_MAD, abs_error_back_ENMO,
    key = metric,
    value = absolute_error
  )
back_KW_df$metric <- as_factor(back_KW_df$metric)

## Running test
back_KW <- kruskal.test(absolute_error ~ metric, data = back_KW_df)
back_KW

## Post hoc
back_posthoc <- kruskalmc(absolute_error ~ metric, data = back_KW_df)
back_posthoc
```

Classification agreement comparison between hip and back placement for each accelerometer metric is show below. For all accelerometer metrics, no differences in classification agreement were observed between accelerometer placements (*p*>0.05).

```{r class_agree_acc_place}
# AC metric (between accelerometers)
## Building data frame
AC_wilcox_df <- class_error_hip_AC %>% 
  left_join(class_error_back_AC, by = c("ID", "speed")) %>% 
  gather(
    abs_error_hip_AC, abs_error_back_AC,
    key = placement,
    value = absolute_error
  )
AC_wilcox_df$placement <- as_factor(AC_wilcox_df$placement)

## Running test
AC_wilcox <- wilcox.test(absolute_error ~ placement, data = AC_wilcox_df)
AC_wilcox

# MAD metric (between MADcelerometers)
## Building data frame
MAD_wilcox_df <- class_error_hip_MAD %>% 
  left_join(class_error_back_MAD, by = c("ID", "speed")) %>% 
  gather(
    abs_error_hip_MAD, abs_error_back_MAD,
    key = placement,
    value = absolute_error
  )
MAD_wilcox_df$placement <- as_factor(MAD_wilcox_df$placement)

## Running test
MAD_wilcox <- wilcox.test(absolute_error ~ placement, data = MAD_wilcox_df)
MAD_wilcox

# ENMO metric (between ENMOcelerometers)
## Building data frame
ENMO_wilcox_df <- class_error_hip_ENMO %>% 
  left_join(class_error_back_ENMO, by = c("ID", "speed")) %>% 
  gather(
    abs_error_hip_ENMO, abs_error_back_ENMO,
    key = placement,
    value = absolute_error
  )
ENMO_wilcox_df$placement <- as_factor(ENMO_wilcox_df$placement)

## Running test
ENMO_wilcox <- wilcox.test(absolute_error ~ placement, data = ENMO_wilcox_df)
ENMO_wilcox
```

# References